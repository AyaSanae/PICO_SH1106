# Raspberry Pico/PicoW Drive SH1106

### Note
Annotations generated by ChatGPT4o-mini 

The OLED Resolution is 128*64 Pixel.

### Example
```C
 int main()
{
  i2c_init(i2c0, OLED_BAUD);

  gpio_set_function(PIN_SCL, GPIO_FUNC_I2C);
  gpio_set_function(PIN_SDA, GPIO_FUNC_I2C);
  gpio_pull_up(PIN_SCL);
  gpio_pull_up(PIN_SDA);

  OLED_Init();
  OLED_Clear();
  OLED_initFrame(frameBuff[0].frame);

  int16_t centerX = 64; 
  int16_t centerY = 32; 
  uint8_t radius = 20;  

  OLED_DrawCircle(frameBuff[0].frame, centerX, centerY, radius);
  for(int i = 0; i < 65535; i ++){
    sleep_ms(5);
    OLED_DrawCircle(frameBuff[0].frame, centerX, centerY, i % 20);
    OLED_RenderFrame_DMA_Clear(frameBuff[0].frame);
  }

  while (1)
  {
  }

  return 1;
}   

```

### Time test
```C
void time_test(){
  uint32_t startTime  = time_us_32(),endTime;
  for (int i = 0; i < 50; i++)
  {
    OLED_Fill_Screen_Pure(0xff);
    OLED_Clear();
  }
  endTime = time_us_32() - startTime;

  printf("Elapse time: %.2fsec\n",endTime * 1e-6);
}

void time_test1(){
  uint32_t startTime  = time_us_32(),endTime;
  for(int k = 0; k < 60; k++){
  for (size_t i = 0; i < OLED_WIDTH; i++)
  {
  
    if (i % 2 == 0)
    {
      OLED_DrawLine(frameBuff[0].frame, i, 0, i, OLED_HEIGHT - 1, 1);
    }

    if(i % 4 == 0)  
      OLED_DrawLine(frameBuff[0].frame, 0, i / 2,OLED_WIDTH-1,i/2 ,1);
  }
    //OLED_Clear();
    //OLED_RenderArray(frameBuff[0].frame, OLED_SIZE_BYTE);
    //OLED_RenderFrame(frameBuff[0].frame);
    OLED_RenderFrame_DMA(frameBuff[0].frame);
  }
  endTime = time_us_32() - startTime;

  printf("Elapse time: %fsec\n",endTime * 1e-6);
}

void OLED_CheckFrame_print(const uint8_t *frame){
  printf("Frame:\n");
  for(int i = 0; i < OLED_HEIGHT_BYTE; i++){
    for(int j = 0; j < OLED_WIDTH; j++){
      printf("0x%.2x, ",frame[j]);
    }
    printf("\n");
  } 
}
```

### Quick-start
Edit your CMakeLists like:
```
# Generated Cmake Pico project file

cmake_minimum_required(VERSION 3.13)

set(CMAKE_C_STANDARD 11)
set(CMAKE_CXX_STANDARD 17)

# Initialise pico_sdk from installed location
# (note this can come from environment, CMake cache etc)
set(PICO_SDK_PATH "/home/aya/PICO/pico-sdk")
set(CMAKE_BUILD_TYPE Release)
if(CMAKE_BUILD_TYPE MATCHES Release)
  add_compile_options(-O3)
  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s")
endif()
set(CMAKE_SYSROOT "/home/aya/PICO/toolchains/arm-none-eabi")
set(CMAKE_EXPORT_COMPILE_COMMANDS 1)

set(PICO_BOARD pico_w CACHE STRING "Board type")

# Pull in Raspberry Pi Pico SDK (must be before project)
include(pico_sdk_import.cmake)

if (PICO_SDK_VERSION_STRING VERSION_LESS "1.4.0")
  message(FATAL_ERROR "Raspberry Pi Pico SDK version 1.4.0 (or later) required. Your version is ${PICO_SDK_VERSION_STRING}")
endif()

project(PICOW_A1 C CXX ASM)

# Initialise the Raspberry Pi Pico SDK
pico_sdk_init()

# Add executable. Default name is the project name, version 0.1

add_executable(PICOW_A1 PICOW_A1.c )

pico_set_program_name(PICOW_A1 "PICOW_A1")
pico_set_program_version(PICOW_A1 "0.1")

pico_enable_stdio_uart(PICOW_A1 0)
pico_enable_stdio_usb(PICOW_A1 1)

add_subdirectory(SH1106)                #Add SH1106

# Add the standard library to the build
target_link_libraries(PICOW_A1
        hardware_i2c
        hardware_clocks
        hardware_dma
        pico_stdlib)

# Add the standard include files to the build
target_include_directories(PICOW_A1 PRIVATE
  ${CMAKE_CURRENT_LIST_DIR}
  ${CMAKE_CURRENT_LIST_DIR}/.. 
  SH1106                            #Add SH1106
)

# Add any user requested libraries
target_link_libraries(PICOW_A1 
        pico_cyw43_arch_none
        SH1106                      #Add SH1106
        )

pico_add_extra_outputs(PICOW_A1)
```
